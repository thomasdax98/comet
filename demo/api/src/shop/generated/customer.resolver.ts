// This file has been generated by comet api-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import { extractGraphqlFields, SubjectEntity, validateNotModified } from "@comet/cms-api";
import { FindOptions } from "@mikro-orm/core";
import { InjectRepository } from "@mikro-orm/nestjs";
import { EntityManager, EntityRepository } from "@mikro-orm/postgresql";
import { Args, ID, Info, Mutation, Parent, Query, ResolveField, Resolver } from "@nestjs/graphql";
import { GraphQLResolveInfo } from "graphql";

import { Customer } from "../entities/customer.entity";
import { Order } from "../entities/order.entity";
import { CustomersService } from "./customers.service";
import { CustomerInput, CustomerUpdateInput } from "./dto/customer.input";
import { CustomersArgs } from "./dto/customers.args";
import { PaginatedCustomers } from "./dto/paginated-customers";

@Resolver(() => Customer)
export class CustomerResolver {
    constructor(
        private readonly entityManager: EntityManager,
        private readonly customersService: CustomersService,
        @InjectRepository(Customer) private readonly repository: EntityRepository<Customer>,
    ) {}

    @Query(() => Customer)
    @SubjectEntity(Customer)
    async customer(@Args("id", { type: () => ID }) id: string): Promise<Customer> {
        const customer = await this.repository.findOneOrFail(id);
        return customer;
    }

    @Query(() => PaginatedCustomers)
    async customers(@Args() { search, filter, sort, offset, limit }: CustomersArgs, @Info() info: GraphQLResolveInfo): Promise<PaginatedCustomers> {
        const where = this.customersService.getFindCondition({ search, filter });

        const fields = extractGraphqlFields(info, { root: "nodes" });
        const populate: string[] = [];
        if (fields.includes("orders")) {
            populate.push("orders");
        }

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const options: FindOptions<Customer, any> = { offset, limit, populate };

        if (sort) {
            options.orderBy = sort.map((sortItem) => {
                return {
                    [sortItem.field]: sortItem.direction,
                };
            });
        }

        const [entities, totalCount] = await this.repository.findAndCount(where, options);
        return new PaginatedCustomers(entities, totalCount);
    }

    @Mutation(() => Customer)
    async createCustomer(@Args("input", { type: () => CustomerInput }) input: CustomerInput): Promise<Customer> {
        const customer = this.repository.create({
            ...input,
        });

        await this.entityManager.flush();

        return customer;
    }

    @Mutation(() => Customer)
    @SubjectEntity(Customer)
    async updateCustomer(
        @Args("id", { type: () => ID }) id: string,
        @Args("input", { type: () => CustomerUpdateInput }) input: CustomerUpdateInput,
        @Args("lastUpdatedAt", { type: () => Date, nullable: true }) lastUpdatedAt?: Date,
    ): Promise<Customer> {
        const customer = await this.repository.findOneOrFail(id);
        if (lastUpdatedAt) {
            validateNotModified(customer, lastUpdatedAt);
        }

        customer.assign({
            ...input,
        });

        await this.entityManager.flush();

        return customer;
    }

    @Mutation(() => Boolean)
    @SubjectEntity(Customer)
    async deleteCustomer(@Args("id", { type: () => ID }) id: string): Promise<boolean> {
        const customer = await this.repository.findOneOrFail(id);
        await this.entityManager.remove(customer);
        await this.entityManager.flush();
        return true;
    }

    @ResolveField(() => [Order])
    async orders(@Parent() customer: Customer): Promise<Order[]> {
        return customer.orders.loadItems();
    }
}
